#+TITLE: Algorithms Data Structures
#+DESCRIPTION: Notes for Algorithms and Data Structures
#+STARTUP: latexpreview

* Big O
** facts
+ if there are no inputs to an algorithm then it considered as $O(1)$
  #+begin_src c
void f( void ) {
    for ( int i = 0; i < 100000; i++ )
}
  #+end_src
** Big O examples
*** O(1)
**** ex1
#+begin_src c
void f( void ) {
    for ( int i = 0; i < 10000; i++ ) {
        printf("%d\n", A[i]);
    }
}
#+end_src

$1000 => O(1)$

*** O(n)
**** ex1
#+begin_src c
void f( int A[], size_t size ) {
    for ( int i = 0; i < size; i++ ) {
        printf("%d\n", A[i]);
    }
}
#+end_src

$n => O(n)$

**** ex2
#+begin_src c
void f( int A[], size_t size ) {
    for ( int i = 0; i < size; i++ ) {
        printf("%d\n", A[i]);
    }
    for ( int i = 0; i < size; i++ ) {
        printf("%d\n", A[i]);
    }
}
#+end_src

$n + n = 2n => O(n)$

**** ex3
#+begin_src c
void f( void ) {
    for ( int i = 0; i < size; i++ ) {
        printf("%d\n", A[i]);
        for ( int i = 0; i < 10000; i++ ) {
            printf("%d\n", A[i]);
        }
    }
}
#+end_src

$n * 1000 => O(n)$

*** O(nÂ²)
#+begin_src c
void f( int A[], size_t size ) {
    for ( int i = 0; i < size; i++ ) {
        for ( int j = 0; j < size; j++ ) {
            printf("%d\n", A[j]);
        }
    }
}
#+end_src
*** O(n*m)
**** ex1
#+begin_src c
void f( int A[], size_t size_A, int B[], size_t size_B ) {
    for ( int i = 0; i < size_A; i++ ) {
        for ( int j = 0; j < size_B; j++ ) {
            printf("%d, %d\n", A[j], B[i]);
        }
    }
}
#+end_src

=size_A= is n and =size_B= is m. so this algorithm will run =O(size_A * size_B)=

$n * m => O(n*m)$
*** O(m^n)
**** ex1
#+begin_src c
void fib( int a ) {
    if ( a == 1 )
        return 1;
    else if ( a <= 0 )
        return 0;
    else
        return fib( a - 1 ) + fib( a - 2 );
}
#+end_src

This algorithm runs recursively and since it does two recursive calls, that means its execution will look line a binary tree. So it's $O(2^n)$

* Algorithms
* Data Structures
** howto
*** choose the right data structure
