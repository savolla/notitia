#+TITLE: C
#+STARTUP: overview
#+AUTHOR: savolla
#+EMAIL: savolla@protonmail.com
#+DATE: Fri Jan  8 22:02:29 2021
#+DESCRIPTION: C Programming Languages

* Facts
** general

- all *global* =const= variables live in FLASH or ROM memory

- If you know that the data is coming from another source and can only be changed by that source and the programmer is not allowed to change the data then use =const volatile=. This is useful when a register is just read-only like temperature sensor etc. and you want to read from it several times.

  #+begin_src c
//
//   programmer can't    pointed address
//  modify the value     can't be changed
//         /               /
uint32_t const volatile *const p = (uint32_t*)TEMPERATURE_SENSOR_REGISTER_ADDR;
//                \
//           data is coming
//           from another source
  #+end_src

- =const= is not the opposite of =volatile=. Some people think it is. This is not true

- =const= guards changes made by the programmer, =volatile= guards changes made by the compiler

- there are 5 options for compiler optimization;
  1. =-O0= : No optimization, debugging friendly
  2. =-O1= : Generates optimized code. Not debugging friendly
  3. =-O2= : More optimized code. Compilation is slow
  4. =-O3= : Super optimized code. Code might have some bugs. Dangerous flag
  5. =-Os= : Optimize for *size*. Beneficial if have _smaller Flash_ size
  6. =-Ofast= : Optimize for *speed*. Beneficial if have _slower CPU_

- benefits of using =const= on function arguments;
  1. increases ~readability~
  2. more ~security~
  3. compiler generates more ~optimized~ code

- =const= does not mean that the value never changes. its only programming safety feature to ensure that the programmer shouldn't try to modify the value

- you can change the value of =const= variables by using a pointer. But not the *global const* variables

- the following expressions are same;
  #+begin_src c
const int x = 10;
int const x = 10;
  #+end_src

- =0b10= represents binary value =0010=

- =!= _not operator_ and =~= _negate operator_ are not the same thing!

- pointers occupy 8 bytes in 64-bit machines, 4 bytes in 32-bit machines and so on. it doesn't matter if we specify different types for pointer such as =char*= =void*= or =unsigned long long int*=. it occupies always the same size.

- IEEE-754 is a standard for representing and modifying floating point numbers

- =main= function _always_ needs to return an =int=

- Types that don't carry any value can represented with Enums. Here are examples;
  #+begin_src c
enum Gender {
    MALE,
    FEMALE
};

enum TrafficLights {
    RED,
    YELLOW,
    GREEN
};

enum MusicGenres {
    ROCK,
    POP,
    JAZZ
};
  #+end_src

- header files include things such as;
  1. macros
  2. types
  3. data structures
  4. variables
  5. functions

- in C, the term *interface* is implemented by using *header* files

- all executable statements must be written inside a function. we do it by writing code into *main* funciton. variable assignements can be used outside of the functions

- all user defined header files must be included in *double quotes*

- you always need to pass _the size of an array_ when using arrays in functions
  #+begin_src c
void printArray(int *arr, size_t size) {
    // some code
}
  #+end_src

- every compiler has _it's own_ *inline assembly* syntax

- macros are always fast and portable

- ternary operators are faster

- ~struct~ deffinitions don't consume memory. Only instances of the struct consume memory

** scenarios for using inline assembly
1. *C variable* --> *CPU register*
2. *CPU register* --> *C variable*
3. operate on multiple C variables inside assembly
** inline assembly is used for;
1. accessing CPU *general purpose registers*
2. accessing CPU *special registers*
3. accessing *stack pointer*
** format specifiers
1. =%p= addresses in hexadeicmal format
2. =%lu= unsigned long  integer
3. =%lld= long long integer
4. =%llu= long long unsigned integer
5. =%llx= long long integer with hexadecimal representation
6. =%c= char data
7. =%lf= double
8. =%f= float
9. =%0.5f= 5 digits after precision
10. =%e= scientific notation
11. =%0.8e= 8 digits after the precision scientific notation
** struct's attribute assignment
you can't assign values to struct attributes. for example the following code will spit out an error
  #+begin_src c
struct A {
    int x = 333;
};
  #+end_src
the valid version of the above code is:
  #+begin_src c
struct A {
    int x;
};
  #+end_src
** struct sizes don't make sense
the following struct's size is 12 bytes.
#+begin_src c
typedef struct A {
    int x;
    char y;
    int z;
} A;
#+end_src
this doesn't make sense right? because;
- int x  : 4 bytes
- char y : 1 byte
- int z  : 4 bytes
it must be 9 bytes.. however compilers make _padding operations_ to keep the memory layout stable. for example after defining variable x which occupies 4 bytes, compiler occupies 1 byte for variable y and right after that does 3 bytes padding! now our memory layout becomes stable ($$2^n$$). then it occupies 4 more bytes for variable z which is 4 bytes. and sizeof operator returns 12

consider the following example of code, where we define one more *char* variable after y;
#+begin_src c
typedef struct A {
    int x;
    char y;
    char k; // new char
    // 2 bytes padding
    int z;
} A;
#+end_src
=sizeof()= operator returns 12 again. because this time compiler adds 2 more bytes padding right after 'k' variable. now it makes sense
** static keyword makes global variables private
yes! when we use *static* on a global variable that is declared in one file (say file1.c) and if another file (file2.c) tryies to access that with *extern* then compiler will complain. so static provides some privacy for globals

- file1.c
#+begin_src c
static int globalVariable;

int main(void) {
    return 0;
}
#+end_src

- file2.c
#+begin_src c
extern int globalVariable;

void changeGlobal() {
    globalVariable = 90000;
}
#+end_src

this won't compile

** c standards
- currently the most widely used language in Embedded is C. but C++ and Rust are gaining popularity

- the first C standard was *ANSI C* this standard is called =C89= or =C90= for short

- more features added to C in 1999. so this standard is called =C99=. C with more features

- in 2011 new standard came out and it is called =C11=

- *C11* is the compiler default for *gcc*

- all standards have *backward compatability*. you can compile C90 code to C99 but can't compile (successfully) from C99 to C90
** static functions are private
functions in one file can be used from another file with *extern* keyword. however if we use the *static* keyword, this function will not be accessible form other files anymore. for example;

- file1.c
  #+begin_src c
static int secret_function(void) {
    return 3;
}
  #+end_src

- file2.c
  #+begin_src c
extern int secret_function(void);

void using_secret_function() {
    int c = secret_function();
}
  #+end_src
if we compile these files with;
#+begin_src sh
gcc file1.c file2.c
#+end_src
compiler will complain
** compiler help the programmer with division operations
- in C if *numerator* is explicitly casted to =float=, compiler will assume that the *denominator* is also =float=. so you don't need to cast the denominator to float again

- the following code will output =integer= type value "26.0000" (no explicit cast);
  #+begin_src c
  float x = 80 / 3;
  printf("%f", x);
  #+end_src

- the following code will output =float= type value "26.6666";
  #+begin_src c
  float x = (float) 80 / 3;
  printf("%f", x);
  #+end_src

- by doing explicit casting, number 3 will be casted to float by compiler _automatically_
** void pointer
- void pointers can hold any value
  #+begin_src c
int a = 112;
char c = 'c';
double d = 0.20;

void *p = &a; // p holds integer (4 bytes)
p = &a; // p now holds char ( 1 byte )
p = &a; // same story
  #+end_src
** working with sleep functions

+ weirdly this code will not output anything on the screen

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother");
          sleep(1);
      }
      return 0;
  }
  #+end_src

+ however when we add *new line* this will work..

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother\n");
          sleep(1);
      }
      return 0;
  }
  #+end_src
** when to use ~volatile~

use ~volatile~ for the variables that can _change unexpectedly_. A variable can be changed by the hardware, by the software and another thread

- Hardware Registers (CPU, Memory-mapped peripheral registers, GPIO registers)
- Peripheral Registers such as *Sensors*
- Global variables (that share data between main code and ISR code)
- Variables that _shared by multiple tasks_ in multi-threaded programming (RTOS)
- software delay counters must be volatile

** when to use ~const~

use ~const~ for the variables like;

- mathematical constants such as $\pi$, $e$
- guarding function argument data with ~CDMP~, ~MDCP~ and ~CDCP~ for secure code

  (CDMP : Constant Data Modifieble Pointer)
  (MDCP : Modifieble Data Constant Pointer)
  (CDCP : Constant Data Constant Pointer)

** void pointers can be used for generic programming

#+begin_src c

#+end_src

** 3 types of infinite loops

some compilers generate warnings for this.
#+begin_src c
while (1) {
   // code
}
#+end_src

works with other languages
#+begin_src c
for (;;) {
   // code
}
#+end_src

Assembly nerds way
#+begin_src c
LOOP:
    // code
    goto LOOP;
#+end_src

Creative one
#+begin_src c
#define ever (;;)

for ever {
    // code
}
#+end_src
** ~true~ and ~false~ in C

#+begin_src c
#include <stdbool.h>

int main(void) {
    bool a = true;
    return 0;
}
#+end_src
** importance of ~stdint.h~

- sizes of data types are depend on *compiler* and *platform architecture*. For example =int= data type can be 4 bytes in some machine and 8 bytes on another machine. Therefore it causes ~portability issues~

- To prevent portability issues caused by type sizes, engineers created a library called =stdint.h=

- Here is the table of provided alias data types

  [[file:./images/screenshot-112.png]]
** unary operators

[[file:./images/screenshot-113.png]]
** pointer arithmatic

- when you increment or decrement a pointer it moves by the size of it's type

#+begin_src c
uint32_t *p = (uint32_t *)0xFFFF0000;
p++;
#+end_src

- the new value of p is =0xFFFF0004=
** importance of ~const~

usage of =const= in _function prototypes_ is a _defencive programming_ technique. it ensures the data that given by the user or another function should not be changed. for example;

1. =copy source=. In cases like =copy= operations, the data that is trying to be copyed should not be changed. This is why we need to use =const=

   #+begin_src c
void copy( uint32_t const *src, uint32_t *dst );
   #+end_src

2. =file paths=.

   #+begin_src c
int open( const char *file_path, int open_flag );
   #+end_src

** constant pointers

*** MDCP

(~Modifiable~ data and ~constant~ pointer)

- can't change the *pointed address*
- can change the *value inside* that address

**** code example

  #+begin_src c
// "p data is the constant pointer that points to type uint32_t"
uint32_t *const p = (uint32_t *)0x40000000;
  #+end_src

**** Allowed Operations

  #+begin_src c
uint32_t *const p = (uint32_t *)0x40000000;
,*p = 40; // can change the value inside 0x40000000
,*p = 10;
  #+end_src

**** Not Allowed Operations

  #+begin_src c
uint32_t *const p = (uint32_t *)0x40000000; // once defined
p = (uint32_t)0x80000000; // This is not allowed
  #+end_src
**** Use Case

The following function can change the data inside the addres but can't change the address itself. This is a safety guard to prevent chaos in sensitive applications like money transfer etc

#+begin_src c
void updateUserData( uint8_t *const pUserAge, uint8_t *const pUserSalary ) {
    // code
}
#+end_src

*** CDMP
~constant~ data and ~modifiable~ pointer

*** CDCP

~constant~ data and ~constant~ pointer

- can't change the *pointed address*
- can't change the *value inside* that address

**** code example

  #+begin_src c
// "p is a constant pointer that points to constant data "
uint32_t const *const p = (uint32_t *)0x40000000;
  #+end_src

**** Allowed Operations

You can only read that is present by the pointer

**** Not Allowed Operations

  #+begin_src c
uint32_t const *const p = (uint32_t *)0x40000000;
p = (uint32_t)0x80000000; // This is not allowed
*p = 45; // This is also now allowed
  #+end_src

**** Use Case

The usage of CDCP is rare. This can be used for some system spesific appications like reading Status Register from the hardware. Accidental modification made to Status Register may cause system failure. Also the address of Status Register is constant. So we pass antother =const= here as well

#+begin_src c
void readStatusRegister( uint8_t const *const pStatusRegister ) {
    // code
}
#+end_src
** volatile pointer

Example:
#+begin_src c
// READ: pStatusReg is a non-volatile pointer that points to volatile uin8 data
uint8_t volatile *pStatusReg;
#+end_src

Use case:
Use this syntax generously whenever you are accessing memory mapped registers in you microcontroller code. Since it is volatile, compiler won't do any optimization and won't break the code

* Tips
** general

- use =packed= compiler attribute when dealing with some tcp or udp packets. so they are already 32-bit packets. You don't want to consume more memory than that

- use =const= keyword when setting =struct= members in ~C99~ method. This will make those values unchangable

  #+begin_src c
  struct A const x = {
    .a = 11;
    .b = 22;
    .c = 33;
  }

  x.b = 999; // gives error
  #+end_src

- use =char string[] = "some string";= insted of =char *string = "some string";=

- use =calloc= instead of =malloc= because it fills the allocated data with zeros. also arcane multiplication operations are not required

- when doing *software delay* make sure you define loop counter =i= _volatile_. Because when you optimize the code with =-O3= flag, compiler will remove the delay line. Compiler thinks that this will slow down the application so it removes that delay

- use =const= keyword generously whenever you find the chance to use it.

- when using *type qualifiers* in C, use this convention because it is easyer to read.

  #+begin_src c
int const x = 10; // READ: x is a constant value of type int
  #+end_src

- when setting spesific bits of a register don't use shift left or right operations. Because some bit vales might be used by other processes and you just reset their values without permission.

- don't mix the following expressions;

  #+begin_src c
  ( 1 < 5 ); // this is boolean expression and outputs 0
  ( 1 << 5 ); // this one is left shift and outputs 0b100000
  #+end_src

- use binary representation of a number when doing left or right shift operations. it makes things easier

  #+begin_src c
uint b = 0;
b |= ( 0b111 < 5 ); // use this instead of expression below
// b |= ( 7 < 5 )
  #+end_src

- use *float* data type when representing *too small numbers*, *too big numbers* and *deciaml numbers*

- you can always use online IDE from [[https://www.onlinegdb.com/][here]]. this makes things easy

- don't forget to use =volatile= for shared variables in your code. Because when compile with optimization flags, compiler might break something. so volatile is a reminder

- include ~stdbool.h~ to use =true=, =false= and =bool= keywords

- use =__asm__= when writing inline assembly. this is because the word =asm= might conflict with other variable name in code

- Whenever you define a variable and it represents a =size= of something, use =size_t= instead of int, long etc

** always write descriptions like this
ignore the commas ','. it is org-mode thing
#+begin_src c
/**
   ,**
   ,* @file      main.c
   ,* @author    savolla
   ,* @version   V1.0
   ,* @brief     Default main function.
   ,**
,*/
#+end_src
** always declare functions before call
- in C, functions are always need to be declared before deffinition
#+begin_src c
void func1(int c); // func declarations
void func2(int c); // func declarations

int main(void) {
    int x = func1(3); // function call
    int y = func2(3); // function call
    return 0;
}

// deffinitions of functions
void func1(int c) {
    return c++;
}

void func2(int c) {
    return c*c;
}
#+end_src
this is the case when you work in just one file. the better solution will be;
1. declare functions in *header* file
2. define functions in another *c file*
3. import header file into main.c
** use this convention while making include guards
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src

** tips for ~#define~ macros

1. don't use semicolons at the end

2. use CAPITALIZED names

3. preprocessors can calculate things for you like ( 60 * 40 * 12 )

4. always be concerned about =sign= and =data size= like 'L' or 'UL' ( 60UL * 40UL * 12UL )

5. always _parentesize macro arguments_
  #+begin_src c
#define MIN(A,B) ( (A) >= (B) ? (B) : (A) )
  #+end_src

** useful =stdint.h= aliases;
- =uintmax_t= : type for the largest _unsigned_ integer
- =intmax_t=  : type for the largest _signed_ integer
- =uintptr_t= : useful if you are unsure about the size of the pointer or when you are coding for unknown architecture like PIC where you are not sure about size of the pointer you can use this

* Concept
** Include Guards
- prevent multiple inclusion of same header file
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src
** Implicit Casting
- this is a *casting type* that made by the compiler
- this happens when the programmer tries to make operations with two different types
  #+begin_src c
  unsigned char c = 0x55;
  unsigned int i = 0x11;
  char z = c + i;
  #+end_src

- compiler gives error when implicit casting results with *data loss*. in the following code programmer is trying to add one byte data with two byte data and assigning the result to =unsigned char= type. "FF" part will be lost and compiler complains

  #+begin_src c
  unsigned char c = 0x80 + 0xFF00;
  #+end_src

- hovewer in the following example the programmer trying to do the same thing but this time there is no data loss. so compiler will not complain

  #+begin_src c
  unsigned char c = 0x80 + 0x0011; // no problem
  #+end_src

** ~#error~ macro

user defined error message. see usage in ~Snippets~
** volatile variable

it is a variable that can change *unexpectedly*. in C, volatile variables are defined like;

#+begin_src c
volatile thermal_sensor_output;
#+end_src
** ~size_t~
** non-cononical mode

in Linux/Unix systems, when functions like =getchar()= is used, the user will always need to press =Return= key for confirmation. To disable this, we need to put the terminal into *non-cononical mode*
** ~base.h~

one important test function lives here is called =text_expect_i=. This function takes two values and compares them

* Library
** stdlib.h
*** calloc

Allocates several memory regions at once

#+begin_src c
int *buf = (int*)calloc( 100, sizeof(int) );
free(buf);
#+end_src

*** malloc

Allocates memory region.

#+begin_src c
int *buf = (int *)malloc(sizeof(int) * 10);
free(buf);
#+end_src

Upper code allocates 40 bytes of memory
** string.h
*** strlen

Returns string length

#+begin_src c
char const *name = "savolla";
size_t length = strlen(name);
#+end_src
*** strdup

Duplicates the string and returns it

#+begin_src c
char const *name = "savolla";
char *tmp = strdup(name);
#+end_src
*** strtok

Splits strings by the delimiter

#+begin_src c
char name[] = "hello world    this is my coding session  ";
char const delimiter = " ";
char *piece = strtok(name, delimiter);

while ( piece != NULL ) {
    printf("%s\n", piece);
    piece = strtok(NULL, " ");
}
#+end_src

* How To
** deal with fixed size structs

Use *bit-fields* for this. For example I'm dealing with a TCP packet which bit structure look like;

[[file:./images/screenshot-120.png]]

#+begin_src c
typedef struct {
    uint32_t crc       :2;
    uint32_t status    :1;
    uint32_t payload   :12;
    uint32_t bat       :3;
    uint32_t sensor    :3;
    uint32_t longAddr  :8;
    uint32_t shortAddr :2;
    uint32_t addrMode  :1;
} Packet;
#+end_src

if we instansiate the =Packet= this struct will be 32-bit no problem. Don't forget to make _all members same type_

** define a struct

#+begin_src c
typedef struct A{
    int a;
    char c;
} A;
#+end_src
** instantiate a struct members

three types of member instantiation are available in C. Consider the following =struct=

#+begin_src c
typedef struct A {
    int a;
    int b;
    int c;
};
#+end_src

*** set variables on instantiation ~C89~

+ this is called ~C89 method~. in this method, the _order is important_

#+begin_src c
A x = {11, 22, 33};
#+end_src

*** set variables on instantiation ~C99~

+ this is called ~C99 method~. in this method, the _order is NOT important_

#+begin_src c
A x = {
    .a=11,
    .b=22,
    .c=33
};
#+end_src

*** set variables after instantiation

#+begin_src c
A x;
x.a = 11;
x.b = 22;
x.c = 33;
#+end_src

** print the address of a variable

#+begin_src c
char c = 'a';
printf( "%p", &c );
#+end_src

** write inline assembly
*** example code
the following example work on =gcc= and takes no special parameters while compiling

1. increment function
  #+begin_src c
  int inc( int number ) {
    __asm__(".intel_syntax noprefix;" // switch to intel syntax
            "mov eax, %0;"
            "inc eax;"
            "mov %1, eax;"
            ".att_syntax prefix;" // enable this to make the following codes work
            : "=r"(number) // outputs(=) to (r)egister
            : "r"(number)); // input comes from (r)egister
    return number;
  }
  #+end_src

2. add function
  #+begin_src c
  int add(int a, int b) {
    int result;
    __asm__(".intel_syntax noprefix;"
            "mov eax, %1;"
            "add eax, %2;"
            "mov %0, eax;"
            ".att_syntax prefix;"
            : "=r"(result)
            : "r"(a), "r"(b));
    return result;
  }
  #+end_src

*** single line inline assembly
+ syntax for *arm-none-eabi-gcc* inline assembly
  #+BEGIN_SRC c
  //
  //    mendatory        use quotes
  //        /              /
        __asm__ volatile( "mov r0, r1" );
  //    --      --------   ----------
  //     \        \            \
  // underscores  type        assembly
  // are optional  qualifier   code
  //
  #+END_SRC

*** multiline assemby
+ use this syntax in case of *multiple asm lines*. only addition is '\n\t' part
  #+BEGIN_SRC c
  __asm__ volatile( "mov r0, r1\n\t"
                    "mov r1, 0x43\n\t"
                    "inc r1\n\t");
  #+END_SRC


+ x86 gcc uses the same syntax but it adds double '%' symbols in front of register names
  #+BEGIN_SRC c
  __asm__ volatile("mov %%rax, 0x1\n\t"
                   "mov %%rbx, %%rax\n\t");
  #+END_SRC


+ here is the full syntax for inline assembly for *arm-none-eaby-gcc*
  #+BEGIN_SRC c
  //               your asm      C vars or imm
  //              mnemonics     values for input  idk yet
  //                  /               /            /
     __asm volatile( code : output : input : clobber );
  //          \                \            \
  //     instruct gcc      C vars go      ':' colons are
  //     to not optimize   here to store   mendatory!
  //     this line         code results
  //
  #+END_SRC

*** pass C variable into CPU register
+ example of scenario *C variable* --> *CPU register*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x = 12;
      __asm volatile( "mov eax, %0" : : "r"(x) : );
      return 0;
  }
  #+END_SRC

*** pass CPU register into C variable
+ example of scenario *CPU register* --> *C variable*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x;
      __asm volatile( "mrs %0, control" : "=r"(x) : : );
      return 0;
  }
  #+END_SRC
** print the actual name of a variable

#+begin_src c
#include <stdio.h>

#define PRINT_VAR_NAME( VARIABLE ) printf("var name: " #VARIABLE);

int main(void) {
    int savolla;
    PRINT_VAR_NAME(savolla)
}
#+end_src
** put terminal in ~non-cononical mode~

put this *function* somewhere in your code

#+begin_src c
void disableCononicalMode() {
  struct termios info;
  tcgetattr(0, &info);     /* get current terminal attirbutes; 0 is the file
                              descriptor for stdin */
  info.c_lflag &= ~ICANON; /* disable canonical mode */
  info.c_cc[VMIN] = 1;     /* wait until at least one keystroke available */
  info.c_cc[VTIME] = 0;    /* no timeout */
  tcsetattr(0, TCSANOW, &info); /* set immediately */
}
#+end_src

and call it from the =main= function

#+begin_src c
#include <stdio.h>

int main(void) {
    disableCononicalMode();

    char c = getchar(); // it will not wait for Enter key now

    return 0;
}
#+end_src
** set back the terminal into ~cononical mode~

#+begin_src c
void setCononicalMode() {
    tcgetattr(0, &info);
    info.c_lflag |= ICANON;
    tcsetattr(0, TCSANOW, &info);
}
#+end_src

** ~#error~ macro usage

if UNIX variable is not defined, don't compile and spit error "Only Unix is supported"

#+begin_src
#ifndef UNIX
#error "Only Unix is supported"
#endif
#+end_src
** represent too big and too small numbers

too big and too small numbers could take too much memory space. So instead of storing the actual number we store only the _exponent_ and _mantissa_ parts

[[file:./images/screenshot-111.png]]

#+begin_src c
double electronCharge = -1.60217662e-19; // charge of an electron
double distance = 2.3651826e+19; // distance between earth and andromeda galaxy in km
#+end_src
** change a ~const~ variable's value

We can only change local =const= values with a pointer

#+begin_src c
int main(void) {

    uint32_t const CONSTANT = 1;
    uint32_t *pointerToCONSTANT = (uint32_t*)&CONSTANT;
    *pointerToCONSTANT = 33;

    return 0;
}
#+end_src

But cannot change the *global constants* because they are placed in =.rodata= section. The following code _will not work_

#+begin_src c
uint32_t const CONSTANT = 1;

int main(void) {

    uint32_t *pointerToCONSTANT = (uint32_t*)&CONSTANT;
    ,*pointerToCONSTANT = 33;

    return 0;
}
#+end_src

* Problems & Solutions
** ~implicit declaration of function $function_name~
This happens when *missing* includes or function prototype problems
