#+TITLE: C
#+STARTUP: overview
#+AUTHOR: savolla
#+EMAIL: savolla@protonmail.com
#+DATE: Fri Jan  8 22:02:29 2021
#+DESCRIPTION: C Programming Languages

* Facts
- benefits of using =const= on function arguments;
  1. increases ~readability~
  2. more ~security~
  3. compiler generates more ~optimized~ code

- =const= does not mean that the value never changes. its only programming safety feature to ensure that the programmer shouldn't try to modify the value

- you can change the value of =const= variables by using a pointer. But not the *global const* variables

- the following expressions are same;
  #+begin_src c
const int x = 10;
int const x = 10;
  #+end_src

- =0b10= represents binary value =0010=

- =!= _not operator_ and =~= _negate operator_ are not the same thing!

- pointers occupy 8 bytes in 64-bit machines, 4 bytes in 32-bit machines and so on. it doesn't matter if we specify different types for pointer such as =char*= =void*= or =unsigned long long int*=. it occupies always the same size.

- IEEE-754 is a standard for representing and modifying floating point numbers

- =main= function _always_ needs to return an =int=

- Types that don't carry any value can represented with Enums. Here are examples;
  #+begin_src c
enum Gender {
    MALE,
    FEMALE
};

enum TrafficLights {
    RED,
    YELLOW,
    GREEN
};

enum MusicGenres {
    ROCK,
    POP,
    JAZZ
};
  #+end_src

- header files include things such as;
  1. macros
  2. types
  3. data structures
  4. variables
  5. functions

- in C, the term *interface* is implemented by using *header* files

- all executable statements must be written inside a function. we do it by writing code into *main* funciton. variable assignements can be used outside of the functions

- all user defined header files must be included in *double quotes*

- you always need to pass _the size of an array_ when using arrays in functions
  #+begin_src c
void printArray(int *arr, size_t size) {
    // some code
}
  #+end_src

- every compiler has _it's own_ *inline assembly* syntax

- macros are always fast and portable

- ternary operators are faster

** scenarios for using inline assembly
1. *C variable* --> *CPU register*
2. *CPU register* --> *C variable*
3. operate on multiple C variables inside assembly
** inline assembly is used for;
1. accessing CPU *general purpose registers*
2. accessing CPU *special registers*
3. accessing *stack pointer*
** format specifiers
1. =%p= addresses in hexadeicmal format
2. =%lu= unsigned long  integer
3. =%lld= long long integer
4. =%llu= long long unsigned integer
5. =%llx= long long integer with hexadecimal representation
6. =%c= char data
7. =%lf= double
8. =%f= float
9. =%0.5f= 5 digits after precision
10. =%e= scientific notation
11. =%0.8e= 8 digits after the precision scientific notation
** struct's attribute assignment
you can't assign values to struct attributes. for example the following code will spit out an error
  #+begin_src c
struct A {
    int x = 333;
};
  #+end_src
the valid version of the above code is:
  #+begin_src c
struct A {
    int x;
};
  #+end_src
** struct sizes don't make sense
the following struct's size is 12 bytes.
#+begin_src c
typedef struct A {
    int x;
    char y;
    int z;
} A;
#+end_src
this doesn't make sense right? because;
- int x  : 4 bytes
- char y : 1 byte
- int z  : 4 bytes
it must be 9 bytes.. however compilers make _padding operations_ to keep the memory layout stable. for example after defining variable x which occupies 4 bytes, compiler occupies 1 byte for variable y and right after that does 3 bytes padding! now our memory layout becomes stable ($$2^n$$). then it occupies 4 more bytes for variable z which is 4 bytes. and sizeof operator returns 12

consider the following example of code, where we define one more *char* variable after y;
#+begin_src c
typedef struct A {
    int x;
    char y;
    char k; // new char
    // 2 bytes padding
    int z;
} A;
#+end_src
=sizeof()= operator returns 12 again. because this time compiler adds 2 more bytes padding right after 'k' variable. now it makes sense
** static keyword makes global variables private
yes! when we use *static* on a global variable that is declared in one file (say file1.c) and if another file (file2.c) tryies to access that with *extern* then compiler will complain. so static provides some privacy for globals

- file1.c
#+begin_src c
static int globalVariable;

int main(void) {
    return 0;
}
#+end_src

- file2.c
#+begin_src c
extern int globalVariable;

void changeGlobal() {
    globalVariable = 90000;
}
#+end_src

this won't compile

** c standards
- currently the most widely used language in Embedded is C. but C++ and Rust are gaining popularity

- the first C standard was *ANSI C* this standard is called =C89= or =C90= for short

- more features added to C in 1999. so this standard is called =C99=. C with more features

- in 2011 new standard came out and it is called =C11=

- *C11* is the compiler default for *gcc*

- all standards have *backward compatability*. you can compile C90 code to C99 but can't compile (successfully) from C99 to C90
** static functions are private
functions in one file can be used from another file with *extern* keyword. however if we use the *static* keyword, this function will not be accessible form other files anymore. for example;

- file1.c
  #+begin_src c
static int secret_function(void) {
    return 3;
}
  #+end_src

- file2.c
  #+begin_src c
extern int secret_function(void);

void using_secret_function() {
    int c = secret_function();
}
  #+end_src
if we compile these files with;
#+begin_src sh
gcc file1.c file2.c
#+end_src
compiler will complain
** compiler help the programmer with division operations
- in C if *numerator* is explicitly casted to =float=, compiler will assume that the *denominator* is also =float=. so you don't need to cast the denominator to float again

- the following code will output =integer= type value "26.0000" (no explicit cast);
  #+begin_src c
  float x = 80 / 3;
  printf("%f", x);
  #+end_src

- the following code will output =float= type value "26.6666";
  #+begin_src c
  float x = (float) 80 / 3;
  printf("%f", x);
  #+end_src

- by doing explicit casting, number 3 will be casted to float by compiler _automatically_
** void pointer
- void pointers can hold any value
  #+begin_src c
int a = 112;
char c = 'c';
double d = 0.20;

void *p = &a; // p holds integer (4 bytes)
p = &a; // p now holds char ( 1 byte )
p = &a; // same story
  #+end_src
** working with sleep functions

+ weirdly this code will not output anything on the screen

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother");
          sleep(1);
      }
      return 0;
  }
  #+end_src

+ however when we add *new line* this will work..

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother\n");
          sleep(1);
      }
      return 0;
  }
  #+end_src
** when to use ~volatile~

use ~volatile~ for the variables like;

- Hardware Registers (CPU etc)
- Peripheral Registers such as *Sensors*
- Non-Stack variables like ISR signals
- Variables that _shared by multiple tasks_ in multi-threaded programming
** when to use ~const~

use ~const~ for the variables like;

- mathematical constants such as $\pi$, $e$
- guarding function argument data with ~CDMP~, ~MDCP~ and ~CDCP~ for secure code

  (CDMP : Constant Data Modifieble Pointer)
  (MDCP : Modifieble Data Constant Pointer)
  (CDCP : Constant Data Constant Pointer)

** void pointers can be used for generic programming

#+begin_src c

#+end_src

** 3 types of infinite loops

some compilers generate warnings for this.
#+begin_src c
while (1) {
   // code
}
#+end_src

works with other languages
#+begin_src c
for (;;) {
   // code
}
#+end_src

Assembly nerds way
#+begin_src c
LOOP:
    // code
    goto LOOP;
#+end_src

Creative one
#+begin_src c
#define ever (;;)

for ever {
    // code
}
#+end_src
** ~true~ and ~false~ in C

#+begin_src c
#include <stdbool.h>

int main(void) {
    bool a = true;
    return 0;
}
#+end_src
** importance of ~stdint.h~

- sizes of data types are depend on *compiler* and *platform architecture*. For example =int= data type can be 4 bytes in some machine and 8 bytes on another machine. Therefore it causes ~portability issues~

- To prevent portability issues caused by type sizes, engineers created a library called =stdint.h=

- Here is the table of provided alias data types

  [[file:./images/screenshot-112.png]]
** unary operators

[[file:./images/screenshot-113.png]]
** pointer arithmatic

- when you increment or decrement a pointer it moves by the size of it's type

#+begin_src c
uint32_t *p = (uint32_t *)0xFFFF0000;
p++;
#+end_src

- the new value of p is =0xFFFF0004=
** importance of ~const~

usage of =const= in _function prototypes_ is a _defencive programming_ technique. it ensures the data that given by the user or another function should not be changed. for example;

1. =copy source=. In cases like =copy= operations, the data that is trying to be copyed should not be changed. This is why we need to use =const=

   #+begin_src c
void copy( uint32_t const *src, uint32_t *dst );
   #+end_src

2. =file paths=.

   #+begin_src c
int open( const char *file_path, int open_flag );
   #+end_src

** constant pointers

*** MDCP

(~Modifiable~ data and ~constant~ pointer)

- can't change the *pointed address*
- can change the *value inside* that address

**** code example

  #+begin_src c
// "p data is the constant pointer that points to type uint32_t"
uint32_t *const p = (uint32_t *)0x40000000;
  #+end_src

**** Allowed Operations

  #+begin_src c
uint32_t *const p = (uint32_t *)0x40000000;
,*p = 40; // can change the value inside 0x40000000
,*p = 10;
  #+end_src

**** Not Allowed Operations

  #+begin_src c
uint32_t *const p = (uint32_t *)0x40000000; // once defined
p = (uint32_t)0x80000000; // This is not allowed
  #+end_src
**** Use Case

The following function can change the data inside the addres but can't change the address itself. This is a safety guard to prevent chaos in sensitive applications like money transfer etc

#+begin_src c
void updateUserData( uint8_t *const pUserAge, uint8_t *const pUserSalary ) {
    // code
}
#+end_src

*** CDMP
~constant~ data and ~modifiable~ pointer

*** CDCP

~constant~ data and ~constant~ pointer

- can't change the *pointed address*
- can't change the *value inside* that address

**** code example

  #+begin_src c
// "p is a constant pointer that points to constant data "
uint32_t const *const p = (uint32_t *)0x40000000;
  #+end_src

**** Allowed Operations

You can only read that is present by the pointer

**** Not Allowed Operations

  #+begin_src c
uint32_t const *const p = (uint32_t *)0x40000000;
p = (uint32_t)0x80000000; // This is not allowed
*p = 45; // This is also now allowed
  #+end_src

**** Use Case

The usage of CDCP is rare. This can be used for some system spesific appications like reading Status Register from the hardware. Accidental modification made to Status Register may cause system failure. Also the address of Status Register is constant. So we pass antother =const= here as well

#+begin_src c
void readStatusRegister( uint8_t const *const pStatusRegister ) {
    // code
}
#+end_src

* Tips

- use =const= keyword generously whenever you find the chance to use it.

- when using *type qualifiers* in C, use this convention because it is easyer to read.

  #+begin_src c
int const x = 10; // READ: x is a constant value of type int
  #+end_src

- when setting spesific bits of a register don't use shift left or right operations. Because some bit vales might be used by other processes and you just reset their values without permission.

- don't mix the following expressions;

  #+begin_src c
  ( 1 < 5 ); // this is boolean expression and outputs 0
  ( 1 << 5 ); // this one is left shift and outputs 0b100000
  #+end_src

- use binary representation of a number when doing left or right shift operations. it makes things easier

  #+begin_src c
uint b = 0;
b |= ( 0b111 < 5 ); // use this instead of expression below
// b |= ( 7 < 5 )
  #+end_src

- use *float* data type when representing *too small numbers*, *too big numbers* and *deciaml numbers*

- you can always use online IDE from [[https://www.onlinegdb.com/][here]]. this makes things easy

- don't forget to use =volatile= for shared variables in your code. Because when compile with optimization flags, compiler might break something. so volatile is a reminder

- include ~stdbool.h~ to use =true=, =false= and =bool= keywords

- use =__asm__= when writing inline assembly. this is because the word =asm= might conflict with other variable name in code

- Whenever you define a variable and it represents a =size= of something, use =size_t= instead of int, long etc

** always write descriptions like this
ignore the commas ','. it is org-mode thing
#+begin_src c
/**
   ,**
   ,* @file      main.c
   ,* @author    savolla
   ,* @version   V1.0
   ,* @brief     Default main function.
   ,**
,*/
#+end_src
** always declare functions before call
- in C, functions are always need to be declared before deffinition
#+begin_src c
void func1(int c); // func declarations
void func2(int c); // func declarations

int main(void) {
    int x = func1(3); // function call
    int y = func2(3); // function call
    return 0;
}

// deffinitions of functions
void func1(int c) {
    return c++;
}

void func2(int c) {
    return c*c;
}
#+end_src
this is the case when you work in just one file. the better solution will be;
1. declare functions in *header* file
2. define functions in another *c file*
3. import header file into main.c
** use this convention while making include guards
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src

** tips for ~#define~ macros

1. don't use semicolons at the end

2. use CAPITALIZED names

3. preprocessors can calculate things for you like ( 60 * 40 * 12 )

4. always be concerned about =sign= and =data size= like 'L' or 'UL' ( 60UL * 40UL * 12UL )

5. always _parentesize macro arguments_
  #+begin_src c
#define MIN(A,B) ( (A) >= (B) ? (B) : (A) )
  #+end_src

** useful =stdint.h= aliases;
- =uintmax_t= : type for the largest _unsigned_ integer
- =intmax_t=  : type for the largest _signed_ integer
- =uintptr_t= : useful if you are unsure about the size of the pointer or when you are coding for unknown architecture like PIC where you are not sure about size of the pointer you can use this

* Concept
** Include Guards
- prevent multiple inclusion of same header file
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src
** Implicit Casting
- this is a *casting type* that made by the compiler
- this happens when the programmer tries to make operations with two different types
  #+begin_src c
  unsigned char c = 0x55;
  unsigned int i = 0x11;
  char z = c + i;
  #+end_src

- compiler gives error when implicit casting results with *data loss*. in the following code programmer is trying to add one byte data with two byte data and assigning the result to =unsigned char= type. "FF" part will be lost and compiler complains

  #+begin_src c
  unsigned char c = 0x80 + 0xFF00;
  #+end_src

- hovewer in the following example the programmer trying to do the same thing but this time there is no data loss. so compiler will not complain

  #+begin_src c
  unsigned char c = 0x80 + 0x0011; // no problem
  #+end_src

** ~#error~ macro

user defined error message. see usage in ~Snippets~
** volatile variable

it is a variable that can change *unexpectedly*. in C, volatile variables are defined like;

#+begin_src c
volatile thermal_sensor_output;
#+end_src
** ~size_t~
** non-cononical mode

in Linux/Unix systems, when functions like =getchar()= is used, the user will always need to press =Return= key for confirmation. To disable this, we need to put the terminal into *non-cononical mode*
** ~base.h~

one important test function lives here is called =text_expect_i=. This function takes two values and compares them

* How To
** define a struct

#+begin_src c
typedef struct A{
    int a;
    char c;
} A;
#+end_src

** print the address of a variable

#+begin_src c
char c = 'a';
printf( "%p", &c );
#+end_src

** write inline assembly
*** example code
the following example work on =gcc= and takes no special parameters while compiling

1. increment function
  #+begin_src c
  int inc( int number ) {
    __asm__(".intel_syntax noprefix;" // switch to intel syntax
            "mov eax, %0;"
            "inc eax;"
            "mov %1, eax;"
            ".att_syntax prefix;" // enable this to make the following codes work
            : "=r"(number) // outputs(=) to (r)egister
            : "r"(number)); // input comes from (r)egister
    return number;
  }
  #+end_src

2. add function
  #+begin_src c
  int add(int a, int b) {
    int result;
    __asm__(".intel_syntax noprefix;"
            "mov eax, %1;"
            "add eax, %2;"
            "mov %0, eax;"
            ".att_syntax prefix;"
            : "=r"(result)
            : "r"(a), "r"(b));
    return result;
  }
  #+end_src

*** single line inline assembly
+ syntax for *arm-none-eabi-gcc* inline assembly
  #+BEGIN_SRC c
  //
  //    mendatory        use quotes
  //        /              /
        __asm__ volatile( "mov r0, r1" );
  //    --      --------   ----------
  //     \        \            \
  // underscores  type        assembly
  // are optional  qualifier   code
  //
  #+END_SRC

*** multiline assemby
+ use this syntax in case of *multiple asm lines*. only addition is '\n\t' part
  #+BEGIN_SRC c
  __asm__ volatile( "mov r0, r1\n\t"
                    "mov r1, 0x43\n\t"
                    "inc r1\n\t");
  #+END_SRC


+ x86 gcc uses the same syntax but it adds double '%' symbols in front of register names
  #+BEGIN_SRC c
  __asm__ volatile("mov %%rax, 0x1\n\t"
                   "mov %%rbx, %%rax\n\t");
  #+END_SRC


+ here is the full syntax for inline assembly for *arm-none-eaby-gcc*
  #+BEGIN_SRC c
  //               your asm      C vars or imm
  //              mnemonics     values for input  idk yet
  //                  /               /            /
     __asm volatile( code : output : input : clobber );
  //          \                \            \
  //     instruct gcc      C vars go      ':' colons are
  //     to not optimize   here to store   mendatory!
  //     this line         code results
  //
  #+END_SRC

*** pass C variable into CPU register
+ example of scenario *C variable* --> *CPU register*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x = 12;
      __asm volatile( "mov eax, %0" : : "r"(x) : );
      return 0;
  }
  #+END_SRC

*** pass CPU register into C variable
+ example of scenario *CPU register* --> *C variable*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x;
      __asm volatile( "mrs %0, control" : "=r"(x) : : );
      return 0;
  }
  #+END_SRC
** print the actual name of a variable

#+begin_src c
#include <stdio.h>

#define PRINT_VAR_NAME( VARIABLE ) printf("var name: " #VARIABLE);

int main(void) {
    int savolla;
    PRINT_VAR_NAME(savolla)
}
#+end_src
** put terminal in ~non-cononical mode~

put this *function* somewhere in your code

#+begin_src c
void disableCononicalMode() {
  struct termios info;
  tcgetattr(0, &info);     /* get current terminal attirbutes; 0 is the file
                              descriptor for stdin */
  info.c_lflag &= ~ICANON; /* disable canonical mode */
  info.c_cc[VMIN] = 1;     /* wait until at least one keystroke available */
  info.c_cc[VTIME] = 0;    /* no timeout */
  tcsetattr(0, TCSANOW, &info); /* set immediately */
}
#+end_src

and call it from the =main= function

#+begin_src c
#include <stdio.h>

int main(void) {
    disableCononicalMode();

    char c = getchar(); // it will not wait for Enter key now

    return 0;
}
#+end_src
** set back the terminal into ~cononical mode~

#+begin_src c
void setCononicalMode() {
    tcgetattr(0, &info);
    info.c_lflag |= ICANON;
    tcsetattr(0, TCSANOW, &info);
}
#+end_src

** ~#error~ macro usage

if UNIX variable is not defined, don't compile and spit error "Only Unix is supported"

#+begin_src
#ifndef UNIX
#error "Only Unix is supported"
#endif
#+end_src
** represent too big and too small numbers

too big and too small numbers could take too much memory space. So instead of storing the actual number we store only the _exponent_ and _mantissa_ parts

[[file:./images/screenshot-111.png]]

#+begin_src c
double electronCharge = -1.60217662e-19; // charge of an electron
double distance = 2.3651826e+19; // distance between earth and andromeda galaxy in km
#+end_src
** change a ~const~ variable's value

We can only change local =const= values with a pointer

#+begin_src c
int main(void) {

    uint32_t const CONSTANT = 1;
    uint32_t *pointerToCONSTANT = (uint32_t*)&CONSTANT;
    *pointerToCONSTANT = 33;

    return 0;
}
#+end_src

But cannot change the *global constants* because they are placed in =.rodata= section. The following code _will not work_

#+begin_src c
uint32_t const CONSTANT = 1;

int main(void) {

    uint32_t *pointerToCONSTANT = (uint32_t*)&CONSTANT;
    ,*pointerToCONSTANT = 33;

    return 0;
}
#+end_src

* Problems & Solutions
** ~implicit declaration of function $function_name~
This happens when *missing* includes or function prototype problems
