#+TITLE: C
#+STARTUP: overview
#+AUTHOR: savolla
#+EMAIL: savolla@protonmail.com
#+DATE: Fri Jan  8 22:02:29 2021
#+DESCRIPTION: C Programming Languages

* Facts
- =main= function _always_ needs to return an =int=

- Types that don't carry any value can represented with Enums. Here are examples;
  #+begin_src c
enum Gender {
    MALE,
    FEMALE
};

enum TrafficLights {
    RED,
    YELLOW,
    GREEN
};

enum MusicGenres {
    ROCK,
    POP,
    JAZZ
};
  #+end_src

- header files include things such as;
  1. macros
  2. types
  3. data structures
  4. variables
  5. functions

- in C, the term *interface* is implemented by using *header* files

- all executable statements must be written inside a function. we do it by writing code into *main* funciton. variable assignements can be used outside of the functions

- all user defined header files must be included in *double quotes*

- you always need to pass _the size of an array_ when using arrays in functions
  #+begin_src c
void printArray(int *arr, size_t size) {
    // some code
}
  #+end_src

- every compiler has _it's own_ *inline assembly* syntax

- macros are always fast and portable

- ternary operators are faster

** scenarios for using inline assembly
1. *C variable* --> *CPU register*
2. *CPU register* --> *C variable*
3. operate on multiple C variables inside assembly
** inline assembly is used for;
1. accessing CPU *general purpose registers*
2. accessing CPU *special registers*
3. accessing *stack pointer*
** format specifiers
1. =%p= addresses in hexadeicmal format
2. =%lu= unsigned long  integer
3. =%lld= long long integer
4. =%llu= long long unsigned integer
5. =%llx= long long integer with hexadecimal representation
6. =%c= char data
** struct's attribute assignment
you can't assign values to struct attributes. for example the following code will spit out an error
  #+begin_src c
struct A {
    int x = 333;
};
  #+end_src
the valid version of the above code is:
  #+begin_src c
struct A {
    int x;
};
  #+end_src
** struct sizes don't make sense
the following struct's size is 12 bytes.
#+begin_src c
typedef struct A {
    int x;
    char y;
    int z;
} A;
#+end_src
this doesn't make sense right? because;
- int x  : 4 bytes
- char y : 1 byte
- int z  : 4 bytes
it must be 9 bytes.. however compilers make _padding operations_ to keep the memory layout stable. for example after defining variable x which occupies 4 bytes, compiler occupies 1 byte for variable y and right after that does 3 bytes padding! now our memory layout becomes stable ($$2^n$$). then it occupies 4 more bytes for variable z which is 4 bytes. and sizeof operator returns 12

consider the following example of code, where we define one more *char* variable after y;
#+begin_src c
typedef struct A {
    int x;
    char y;
    char k; // new char
    // 2 bytes padding
    int z;
} A;
#+end_src
=sizeof()= operator returns 12 again. because this time compiler adds 2 more bytes padding right after 'k' variable. now it makes sense
** static keyword makes global variables private
yes! when we use *static* on a global variable that is declared in one file (say file1.c) and if another file (file2.c) tryies to access that with *extern* then compiler will complain. so static provides some privacy for globals

- file1.c
#+begin_src c
static int globalVariable;

int main(void) {
    return 0;
}
#+end_src

- file2.c
#+begin_src c
extern int globalVariable;

void changeGlobal() {
    globalVariable = 90000;
}
#+end_src

this won't compile

** c standards
- currently the most widely used language in Embedded is C. but C++ and Rust are gaining popularity

- the first C standard was *ANSI C* this standard is called =C89= or =C90= for short

- more features added to C in 1999. so this standard is called =C99=. C with more features

- in 2011 new standard came out and it is called =C11=

- *C11* is the compiler default for *gcc*

- all standards have *backward compatability*. you can compile C90 code to C99 but can't compile (successfully) from C99 to C90
** static functions are private
functions in one file can be used from another file with *extern* keyword. however if we use the *static* keyword, this function will not be accessible form other files anymore. for example;

- file1.c
  #+begin_src c
static int secret_function(void) {
    return 3;
}
  #+end_src

- file2.c
  #+begin_src c
extern int secret_function(void);

void using_secret_function() {
    int c = secret_function();
}
  #+end_src
if we compile these files with;
#+begin_src sh
gcc file1.c file2.c
#+end_src
compiler will complain
** compiler help the programmer with division operations
- in C if *numerator* is explicitly casted to =float=, compiler will assume that the *denominator* is also =float=. so you don't need to cast the denominator to float again

- the following code will output =integer= type value "26.0000" (no explicit cast);
  #+begin_src c
  float x = 80 / 3;
  printf("%f", x);
  #+end_src

- the following code will output =float= type value "26.6666";
  #+begin_src c
  float x = (float) 80 / 3;
  printf("%f", x);
  #+end_src

- by doing explicit casting, number 3 will be casted to float by compiler _automatically_
** void pointer
- void pointers can hold any value
  #+begin_src c
int a = 112;
char c = 'c';
double d = 0.20;

void *p = &a; // p holds integer (4 bytes)
p = &a; // p now holds char ( 1 byte )
p = &a; // same story
  #+end_src
** working with sleep functions

+ weirdly this code will not output anything on the screen

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother");
          sleep(1);
      }
      return 0;
  }
  #+end_src

+ however when we add *new line* this will work..

  #+begin_src c
  #include <unistd.h>
  #include <stdio.h>

  int main(void) {
      while (1) {
          printf("hello brother\n");
          sleep(1);
      }
      return 0;
  }
  #+end_src
** when to use ~volatile~

use ~volatile~ for the variables like;

- Hardware Registers (CPU etc)
- Peripheral Registers such as *Sensors*
- Non-Stack variables like ISR signals
- Variables that _shared by multiple tasks_ in multi-threaded programming
** void pointers can be used for generic programming

#+begin_src c

#+end_src

** 3 types of infinite loops

some compilers generate warnings for this.
#+begin_src c
while (1) {
   // code
}
#+end_src

works with other languages
#+begin_src c
for (;;) {
   // code
}
#+end_src

Assembly nerds way
#+begin_src c
LOOP:
    // code
    goto LOOP;
#+end_src

Creative one
#+begin_src c
#define ever (;;)

for ever {
    // code
}
#+end_src
** ~true~ and ~false~ in C

#+begin_src c
#include <stdbool.h>

int main(void) {
    bool a = true;
    return 0;
}
#+end_src

* Tips

- you can always use online IDE from [[https://www.onlinegdb.com/][here]]. this makes things easy

- don't forget to use =volatile= for shared variables in your code. Because when compile with optimization flags, compiler might break something. so volatile is a reminder

- include ~stdbool.h~ to use =true=, =false= and =bool= keywords

- use =__asm__= when writing inline assembly. this is because the word =asm= might conflict with other variable name in code

- Whenever you define a variable and it represents a =size= of something, use =size_t= instead of int, long etc

** always write descriptions like this
ignore the commas ','. it is org-mode thing
#+begin_src c
/**
   ,**
   ,* @file      main.c
   ,* @author    savolla
   ,* @version   V1.0
   ,* @brief     Default main function.
   ,**
,*/
#+end_src
** always declare functions before call
- in C, functions are always need to be declared before deffinition
#+begin_src c
void func1(int c); // func declarations
void func2(int c); // func declarations

int main(void) {
    int x = func1(3); // function call
    int y = func2(3); // function call
    return 0;
}

// deffinitions of functions
void func1(int c) {
    return c++;
}

void func2(int c) {
    return c*c;
}
#+end_src
this is the case when you work in just one file. the better solution will be;
1. declare functions in *header* file
2. define functions in another *c file*
3. import header file into main.c
** use this convention while making include guards
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src

** tips for ~#define~ macros

1. don't use semicolons at the end

2. use CAPITALIZED names

3. preprocessors can calculate things for you like ( 60 * 40 * 12 )

4. always be concerned about =sign= and =data size= like 'L' or 'UL' ( 60UL * 40UL * 12UL )

5. always _parentesize macro arguments_
  #+begin_src c
#define MIN(A,B) ( (A) >= (B) ? (B) : (A) )
  #+end_src

* Concept
** Include Guards
- prevent multiple inclusion of same header file
  #+begin_src c
#ifndef _YOUR_HEADER_H__
#define _YOUR_HEADER_H__
// your function declarations go here
#endif /* _YOUR_HEADER_H__ */
  #+end_src
** Implicit Casting
- this is a *casting type* that made by the compiler
- this happens when the programmer tries to make operations with two different types
  #+begin_src c
  unsigned char c = 0x55;
  unsigned int i = 0x11;
  char z = c + i;
  #+end_src

- compiler gives error when implicit casting results with *data loss*. in the following code programmer is trying to add one byte data with two byte data and assigning the result to =unsigned char= type. "FF" part will be lost and compiler complains

  #+begin_src c
  unsigned char c = 0x80 + 0xFF00;
  #+end_src

- hovewer in the following example the programmer trying to do the same thing but this time there is no data loss. so compiler will not complain

  #+begin_src c
  unsigned char c = 0x80 + 0x0011; // no problem
  #+end_src

** ~#error~ macro

user defined error message. see usage in ~Snippets~
** volatile variable

it is a variable that can change *unexpectedly*. in C, volatile variables are defined like;

#+begin_src c
volatile thermal_sensor_output;
#+end_src
** ~size_t~
** non-cononical mode

in Linux/Unix systems, when functions like =getchar()= is used, the user will always need to press =Return= key for confirmation. To disable this, we need to put the terminal into *non-cononical mode*
** ~base.h~

one important test function lives here is called =text_expect_i=. This function takes two values and compares them



* How To
** define a struct

#+begin_src c
typedef struct A{
    int a;
    char c;
} A;
#+end_src

** print the address of a variable

#+begin_src c
char c = 'a';
printf( "%p", &c );
#+end_src

** write inline assembly
*** example code
the following example work on =gcc= and takes no special parameters while compiling

1. increment function
  #+begin_src c
  int inc( int number ) {
    __asm__(".intel_syntax noprefix;" // switch to intel syntax
            "mov eax, %0;"
            "inc eax;"
            "mov %1, eax;"
            ".att_syntax prefix;" // enable this to make the following codes work
            : "=r"(number) // outputs(=) to (r)egister
            : "r"(number)); // input comes from (r)egister
    return number;
  }
  #+end_src

2. add function
  #+begin_src c
  int add(int a, int b) {
    int result;
    __asm__(".intel_syntax noprefix;"
            "mov eax, %1;"
            "add eax, %2;"
            "mov %0, eax;"
            ".att_syntax prefix;"
            : "=r"(result)
            : "r"(a), "r"(b));
    return result;
  }
  #+end_src

*** single line inline assembly
+ syntax for *arm-none-eabi-gcc* inline assembly
  #+BEGIN_SRC c
  //
  //    mendatory        use quotes
  //        /              /
        __asm__ volatile( "mov r0, r1" );
  //    --      --------   ----------
  //     \        \            \
  // underscores  type        assembly
  // are optional  qualifier   code
  //
  #+END_SRC

*** multiline assemby
+ use this syntax in case of *multiple asm lines*. only addition is '\n\t' part
  #+BEGIN_SRC c
  __asm__ volatile( "mov r0, r1\n\t"
                    "mov r1, 0x43\n\t"
                    "inc r1\n\t");
  #+END_SRC


+ x86 gcc uses the same syntax but it adds double '%' symbols in front of register names
  #+BEGIN_SRC c
  __asm__ volatile("mov %%rax, 0x1\n\t"
                   "mov %%rbx, %%rax\n\t");
  #+END_SRC


+ here is the full syntax for inline assembly for *arm-none-eaby-gcc*
  #+BEGIN_SRC c
  //               your asm      C vars or imm
  //              mnemonics     values for input  idk yet
  //                  /               /            /
     __asm volatile( code : output : input : clobber );
  //          \                \            \
  //     instruct gcc      C vars go      ':' colons are
  //     to not optimize   here to store   mendatory!
  //     this line         code results
  //
  #+END_SRC

*** pass C variable into CPU register
+ example of scenario *C variable* --> *CPU register*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x = 12;
      __asm volatile( "mov eax, %0" : : "r"(x) : );
      return 0;
  }
  #+END_SRC

*** pass CPU register into C variable
+ example of scenario *CPU register* --> *C variable*
  #+BEGIN_SRC c
  #include <stdint.h>
  int main(void) {
      uint32_t x;
      __asm volatile( "mrs %0, control" : "=r"(x) : : );
      return 0;
  }
  #+END_SRC
** print the actual name of a variable

#+begin_src c
#include <stdio.h>

#define PRINT_VAR_NAME( VARIABLE ) printf("var name: " #VARIABLE);

int main(void) {
    int savolla;
    PRINT_VAR_NAME(savolla)
}
#+end_src
** put terminal in ~non-cononical mode~

put this *function* somewhere in your code

#+begin_src c
void disableCononicalMode() {
  struct termios info;
  tcgetattr(0, &info);     /* get current terminal attirbutes; 0 is the file
                              descriptor for stdin */
  info.c_lflag &= ~ICANON; /* disable canonical mode */
  info.c_cc[VMIN] = 1;     /* wait until at least one keystroke available */
  info.c_cc[VTIME] = 0;    /* no timeout */
  tcsetattr(0, TCSANOW, &info); /* set immediately */
}
#+end_src

and call it from the =main= function

#+begin_src c
#include <stdio.h>

int main(void) {
    disableCononicalMode();

    char c = getchar(); // it will not wait for Enter key now

    return 0;
}
#+end_src
** set back the terminal into ~cononical mode~

#+begin_src c
void setCononicalMode() {
    tcgetattr(0, &info);
    info.c_lflag |= ICANON;
    tcsetattr(0, TCSANOW, &info);
}
#+end_src

** ~#error~ macro usage

if UNIX variable is not defined, don't compile and spit error "Only Unix is supported"

#+begin_src
#ifndef UNIX
#error "Only Unix is supported"
#endif
#+end_src
* Problems & Solutions
** ~implicit declaration of function $function_name~
This happens when *missin* includes or function prototype problems
