#+TITLE: Embedded Systems
#+AUTHOR: savolla
#+EMAIL: savolla@protonmail.com
#+DATE: Fri Jan  8 22:02:29 2021
#+STARTUP: overview
#+OPTIONS: Knowledge collected for Embedded Systems

* TODO Articles

Read and learn things from these. Extract knowledge and store here

+ [[https://jaycarlson.net/][jay carlson's entire website]]
+ [[https://www.livecareer.com/resume-search/r/senior-embedded-software-engineer-29aac52d404b476e87fdb747db1370e7][good example CV for embedded systems]]
+ [[https://wiki.archlinux.org/index.php/Udev][what is udev]] useful knowledge for *Embedded Linux applications*

* TODO Books

** An Embedded Software Primer
[[file:./images/screenshot-09.png]]
According to the Professor at ODTU who gives courses on embedded systems, he recommended this book as the "best resource"

* TODO shovel :container:

this is my embedded development container project. under this header I collect necessary tools for my container

** capabilities
*** supported MCUs
Supported by =sdcc=
**** Intel MCS51
- 8031
- 8032
- 8051
- 8052
**** Zilog Z80
- z80
- z180
- gbz80
- Rabbit 2000/3000
- Rabbit 3000A
- TLCS-90
**** HC08
- hc08
- s08
**** Padauk
- pdk14
- pdk15
**** Microchip
- PIC16
- PIC18
**** Padauk
- pdk13

** install these
*** serial com

#+begin_src sh
sudo pacman -S minicom
sudo pacman -S picocom
sudo pacman -S openocd
#+end_src

*** debuggers

#+begin_src sh
sudo pacman -S gnu-arm-eabi-gdb
#+end_src

*** cross-compilers

#+begin_src sh
sudo pacman -S gnu-arm-eabi-gcc sdcc
#+end_src

*** rust

#+begin_src sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
cargo install itm
cargo install cargo-binutils
#+end_src

*** bluetooth interfacing

#+begin_src sh
sudo pacman -S bluez bluez-utils rfkill
#+end_src

*** testing

#+begin_src sh
git clone https://github.com/ThrowTheSwitch/Unity.git
git pull
#+end_src


* Tips

- *Reset Handler* function should copy the *.data* section from *code memory* to SRAM

- when an MCU has more than one SRAM don't let this confuse you. This is a totally a marketing technique. It actually have only one SRAM

- don't give the *elf* executable to the customer. because there are tools like elf analizers which can decompile all the code to the C language and customers will know everything about the software implementation. give them .bin or .hex file instead. use tools like *objcopy*

- use *ternary operators* instead of *if-else* in embedded systems. it increases performance

- don't use SPI when distance is more than 1 meter

* Facts

- Memory Map of ARM Cortex Mx processor
  [[file:./images/screenshot-117.png]]

- Most of the time the *Memory Map* is mentioned in the *Reference Manual* of the MCU

- STM32Fx based MCUs have a concept called *Ports*. Each port has 16 pins where you can connect external peripherals such as LED, Display, button, Bluetotth Transciever, EEPROM, joystick, keypad etc. for example in STM32F407VGT6 there are A,B,C,D,E ports

- in STM32Fx MCUs each I/O Port has it's own CPU peripheral hardware inside the MCU. This hardware has registers which can be read and write into. In this way we can read and write to external peripherals that we connect to GPIOs
  [[file:./images/screenshot-116.png]]

- Arm Cortex-M4 has *Thumb-2* ISA. Thumb-2 is a collection of 16-bit and 32-bit instructions

- EEPROM and Flash are both *electrically erasable* memories but the fabrication of them are completely different. Flash is *faster* and *cheaper* than EEPROM

- if you see something like "Xtal Ocsillators" in a MCU datasheet as a *peripheral* then it means that you don't need to connect any Cristals to supply timer to this MCU. It can run on its own

- ARM's business model is based on *only designing* chips _does not manufacture_. Intel on the other hand designs and manufactures their chips

- We don't use =main= function with *command line arguments* in embedded. So main function always written with =void= parameter like =int main(void)=

** Why using ~malloc()~ or ~new~ is bad in embedded

1. *Out of memory* problems can occur since Embedded Environments are low memory

2. Slow. Dynamic memory allocation is either relatively slow and gets slower as the memory gets fragmented

3. If you are going to use the same dynamic memory for different threads and interrupts then allocation/freeing routines need to perform locking which can cause problems servicing interrupts fast enough.

4. Dynamic memory allocation makes it very difficult to debug

5. Cause *Memory Leaks*

** Pointer use cases in embedded;
- configure the peripheral register addresses
- Read/Write into peripheral data register
- Read/Write into SRAM/FLASH locations

** what happens before main()
*** According to Making Embedded Systems book
0. _start function
1. Early low-level initialization, such as;
   a. Configuring processor registers
   b. Initializing external memory
   c. Enabling caches
   d. Configuring the MMU
2. Stack initialization, making sure that the stack is properly aligned per the ABI requirements
3. Frame pointer initialization
4. C/C++ runtime setup
5. Initializing other scaffolding required by the system
6. Jumping to main
7. Exiting the program with the return code from main
*** According to Programming Embedded Systems book
** Anatomy of a Typical Small MCU

[[file:./images/screenshot-109.png]]

When we power this MCU;
1. Clock starts to send digital signals to CPU in very high speed. So CPU will start working
2. CPU starts to read the *Program Memory* from address 0x00000000 to 0xFFFFFFFF
3. CPU generates the address like 0x00000000 sends this address to *Address Bus*
4. Program Memory outputs the instruction at 0x00000000 and sends the instruction through *Data Bus*
5. CPU has some internal mechanisms to decode the instruction. It decodes and executes.
6. CPU increments the address and reads the next instruction from the Program Memory

While the read of Program Memory, sometimes CPU needs to store some temporary memory to the RAM which here represented as *Data Memory*. I/O is an interface between various sensors, actuators and CPU.

** Applications of Bitwise Operations

in embedded C program, most of the time you will be doing;

- *testing* of bits (&)
- *setting* of bits (|)
- *clearing* of bits (~ and &)
- *toggling* of bits (^)

* How To
** run ARM binaries on x86 Linux
** how to specify a pointer to some address

#+begin_src c
uint32_t *p = (uint32_t *)0xFFFF0000;
#+end_src
** use bitwise operators

#+begin_src c
// Test
uint32_t bitwiseTest( uint32_t data, uint32_t bitMask ) {
    return (data & bitMask);
}

// Set
uint32_t bitwiseSet( uint32_t data, uint32_t bitMask ) {
    return (data | bitMask);
}

// Clear
uint32_t bitwiseClear( uint32_t data, uint32_t bitMask ) {
    return (data & ~(bitMask));
}

// Toggle
uint32_t bitwiseToggle( uint32_t data, uint32_t bitMask ) {
    return (data ^ bitMask);
}
#+end_src

* Concepts
** Communication Protocol
*** I²C

- developed by Philips (now NXP)

- also called *TWI* /"Two Wired Interface/

- serial communication protocol

- I²C enables designers to add more GPIO pins to MCU

- some MCUs have this feature

- I²C bus consists of two data lines;
  1. SDA (serial data line)
  2. SCA (serial clock line)

- with I²C you can add bunch of *slaves* such as;
  a. SPD EEPROMS
  b. LED/LCD drivers
  c. NVRAM CHIPS
  d. DAC, ADC
  e. Sound Controller
  f. sensors
  g. write/read real time clocks

- slaves are easily replacable

- here is how I²C looks like
 [[file:./images/screenshot-71.png]]

- If you don't have enough I/O pins, you can use I²C since it't TWI

- I²C requires two *pull up* resistors to let the current flow over *SDL* and *SCL*

[[file:./images/screenshot-102.png]]

*** SWD

- serial wired debug
- two-wire protocol for accessing the ARM debug interface
- alternative to JTAG (just in ARM MPUs)
- has two wires;
  1. SWDIO : bidirectional data line
  2. SWCLK : clock driven by the host
- capabilities of SWD;
  a. program MCU's internal flash memory
  b. access memory regions
  c. add breakpoints
  d. stop/run CPU
  e. printf style debugging
*** SPI

- Most chips use SPI protocol;

  + Memory Chips /(EEPROMS, SD Cards)/
  + Display Modules /(OLED, LCD)/
  + ADCs mostly use SPI

- In SPI there is a notion of *Master* and *Slave*

- Master: Starts the data transaction, sends and recieves the data from Slaves

- Master is mostly a Microcontroller (MCU) or FPGA

- SPI interface has 4 different elements;

 [[file:./images/screenshot-99.png]]

 *SCLK* - Serial Clock
 *MOSI* - Master Out Slave In
 *MISO* - Master In Slave Out
 *SS* - Slave Select

- SPI protocol used the *CLOCK*. So it is a synchronized Protocol

- CONS of this protocol is that it needs a GPIO pin per peripheral. While I²C does not. But since I²C uses adresses, slaves need to do a little bit operation to understand if the incoming data is for them or not. SPI is simpler and uses *SS* slave select

- *SS* will select the slave. Basically it says "hey slave open your ear and listen!" while other slaves are not listening and don't know anything about the incoming data

- Below, there is an example for *multiple slaves*

 [[file:./images/screenshot-100.png]]

- SPI is faster than I²C and UART

- requires more pins than UART and I²C

- used in short distances. don't use SPI when distance is more than 1 meter

** Hardware
*** DMA

- direct memory access
- translator between peripherals and the RAM

*** ITM unit

- Instrumentation Trace Macrocell Unit

- a unit inside the *ARM Cortex M4* Processor

- this is the core hardware that provides *printf style* debugging via SWD protocol

- contains a FIFO buffer. Programmer can print to this buffer and ITM will spit out the content

*** MEMS

Micro Electro-Mechanical Systems. see [[https://www.youtube.com/watch?v=i2U49usFo10][this video]]

*** NVRAM

- non volatile RAM
- data does not go away when power goes off
- this is a costy component
 [[file:./images/screenshot-72.png]]

*** RTC

Real Time Clock
*** OTP
One time Progammable memory. The actual ROMs
*** MPU
- Memory Protection Unit. Provided by many modern Microprocessors.
- Stack Overflow protection
- Isolation of discrete tasks
- if a Processor has it, then it can run RTOS
*** Accelerometer

[[file:./images/screenshot-89.png]]
Your phone screen rotates automatically when you rotate the phone. A *sensor* called Accelerometer is used in these applications. It detects 3D planes. This is a MEMS device

*** Magnetometer

[[file:./images/screenshot-90.png]]
a MEMS device that can be used as a *Compass*. We have it inside our smart phones. All compass apps that you download from app store uses this sensor.

*** Gyroscope

[[file:./images/screenshot-91.png]]
a MEMS device that can detect *rotation* and *angular velocity*.

*** Carry Flag :TODO:
*** Zero Flag

set if result is 0. reset if non-zero
*** Parity Flag

set to 1 if last operation result is *even*. reset if odd
*** Interrupt Latency

Time passed before CPU reads the interrupt and finally returns

=HW= -[IRQ]-> =ISR= -[IRQ]-> =CPU=

Interrupt Latency happends here

*** Status Register

a.k.a. Flag register. Contains the information about current state of the Processor. Flag register names in different architectures;

- *x86* : FLAGS
- *AVR* : SREG
- *ARM* : APSR /(application program status register)/
*** PIC

- stands for *Peripheral Interface Controller*
- a microcontroller produced by *Microchip*
- widely used in 8-bit apllications
- Here is the Architecture of =PIC16F887=

 [[file:./images/screenshot-110.png]]
*** MPROM

Type of ROM. Once you program it you can never erase it
*** EEPROM

- You can erase it.
- Sometimes datasheets indicate EEPROMs as ROMs. They are actually erasable don't worry
*** Flash

- Same as EEPROM but faster and cheaper
- Dominates the Embedded World as *code memory*
*** FRAM

- Ferroelectric Random Access Memory
- Expen$ive
- _Access speed is higher than Flash_
- Tipically this kind of Memory is found in Texas Instruments Microcontrollers like ~MSP430FR2422~
- Can be effective in _ultra low power_ applications
*** AHB

"Advanced High Performance Bus" this is a specific Address Bus which used in ARM CPUs. This bus connects CPU, Flash, RAM and other peripherals

** Software
*** Unity
unit testing for c (especially embedded software)

*** newlib

C standard library implementation intended for use on embedded systems

*** OpenOCD

Open (source) on Circuit Debugger. This is a software tool that helps embedded programmers to debug/flash embedded code to Microcontrollers. Supports JTAG and SWD protocols

*** minicom

serial communication software for linux. (PuTTY equivalent)

*** TensorFlow Light

a version of tensorflow for specifically *microcontrollers*

*** ISR

this is a function that waits interupts from hardware. when it recieves a signal then it sends this signal to the CPU and interupts the already running process. When ISR is complete then the active process continues to proceed

The example of ISR is *keyboard handler* function;

[Key Press] -> [Keyboard] -> [Signal] -> [Keyboard ISR] -> [Signal] -> [CPU]
*** SysML

system modelling language inherited from UML
*** ~sbrk~ and ~brk~

- These are *systemcall*
- Every Heap memory region have a *boundary* called *break*
- =sbrk= and =brk= adjust this *brake* value by increasing or decreasing
- =malloc= function is actually using thsese systemcalls to allocate heap memory
- =sbrk= syscall returns the address of the *brake*
- =brk= however returns 0 on success and non-zero on failure

 [[file:./images/screenshot-108.png]]

** Jargon
*** Interrupt Storm

- this event happends when amount of _incoming interrupts_ is an astronomic number
- ISRs are working constantly and the main system is busy all the time.
- system is not responsive anymore.
- requires a reset

*** Assembler

translates the assembly language into machine language

*** ISA

The assembly language must support a different set of machine instructions. The design of the machine language *encoding* is called the /instruction set architecture (ISA)/. it's actually can be thought as *the flavor of assembly* like x86, Thumb etc

*** Sensor
- cameras
- Depth sensor
- Buttons
- switches
- encoders
- GPS
- IMU
*** Actuator

anything that moves

- Wheels
- Wings
- Rotor
- Motor
- Arm
- Servo
- Step motor

*** Robot

sensors + actuators + control = robot

*** Renesas

Microcontrollers designer just like ARM. check [[https://en.wikipedia.org/wiki/Renesas_Electronics][this]] for more info
*** Full Duplex

When data is *coming* and *going* _at the same time_ using two caples. This concept is most important in communication protocols. For example SPI is Full Duplex thanks to MISO and MOSI data lines

*** Half Duplex

When data flows in one direction and two devices need to wait each other before sending the data. This can be thought as when two people talk on the phone
*** Bit Masking

it's a binary manipulation technique where we test some specific bits of a bit stream. To test the specific bits we create a *binary pattern* called *Bit Mask* and then we =&= this pattern with the actual bit stream

[[file:./images/screenshot-115.png]]

We can also do other operations like setting bits, toggling etc

* Platforms
** STM32F407VGT6

- comes with it's own debugger called *ST-LINK/V2-A*

- the overview of the platform:
  [[./images/screenshot-73.png]]

- comes with *ARM Cortex-M4*

- 168 MHz CPU speed

- has DSP

- has MPU (memory protection unit)

- internal peripherals

  1. two 3-axis accelometers
  2. one microphone
  3. DAC jack
  4. 4 LEDs
  5. 2 push buttons
* Problems & Solutions
* Tutorials
** Use Rust for Embedded Development
*** install packages first
**** rust

install rust first

#+begin_src sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

**** itm

a rust *crete* for interfacing ITM unit inside Cortex-M4 processor. Makes *printf* debug style easier

#+begin_src sh :results none
cargo install itm
#+end_src

**** OpenOCD

#+begin_src sh
sudo pacman -S openocd
#+end_src
**** arm-none-eabi-gdb

The GNU Debugger for the ARM EABI (bare-metal) target

#+begin_src sh
sudo pacman -S arm-none-eabi-gdb
#+end_src
**** cargo-binutils

install /nm, objcopy, objdump, size, ld, lld, nm/ tools for rust.

#+begin_src sh
cargo install cargo-binutils
#+end_src

**** bluetooth packages

#+begin_src sh
sudo pacman -S bluez bluez-utils rfkill
#+end_src

**** serial com

#+begin_src sh
sudo pacman -S minicom picocom
#+end_src

